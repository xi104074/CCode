




/*** Note 笔记 抽象表  表对象  

    1. 符号的力量
    2. 对一个通用 的表 的特性 的提取 
        -- 以“行”为单位 Item
        -- 元素 是 同类型的 
        -- 空间描述： 
            元素大小 
            整个表的大小
            表首指针
        -- 对链表的扩展
            -- 链节点 相对Item 首址的偏移值
        -- 表应该有一个表ID
        -- 从表的动态性来说：
            -- 是否需要增加 衍生接口，
            -- 在Item 增删改时 影响哪些元素？
        
        -- 核心： 真正实现 断点续查 功能 接口及函数 ！！
            -- 数组形式已经实现
            
        

    3. search函数 返回两种关键信息： 指针及偏址信息
    4. 对于 链表 形式的 表
        额外条件：需要具体表项结构，
        -- 本质需要具体 链表节点与与 实际表项结构首地址之间的偏址
        -- 需要一个AbstTable结构中需要增加一个 LNodeOffset 项
        -- pTableHead 
            -- 在 DLink 中，CC_DLink_t g_DlinkTableHead ；pTableHead=&g_DlinkTableHead
            -- pTableHead是指针的指针
            
            -- 在 Array 数组中 
            -- pTableHead是指针（一级）
    5. 比较有用的函数 ： 
        DLinkElements_Collection 将 链表中的所有元素 复制到 指定数组缓存中
        -- 方便收集，观察链表数据
        
    6. 表的遍历 代码框架 
        形式1 : 与Search相似， 将对每个Item 处理部分 提取 变为一个 函数
            -- 函数接口 int Traverse_DoFunc(AbstTable_t pTable,uint8* pInItem,int inx)
            -- 遍历处理时 常常有许多额外需要的输入参数。此形式不适合
            
        形式2 基于search 函数 通过绑定一个特殊的比较函数；
            -- search 返回 表中的每一个Item;
            -- 对于 数组形式 ，此结构 额外增加了 函数的调用；
            -- 对于 链表形式 ，除函数调用的开销，
                -- 链表中进行的转移操作开销是大大的增加
                -- 1+2+。。N次--一次遍历需要 (N+1)*N/2 次 转移
            -- 所以形式二有效率的缺陷
            -- 设 转移操作开销 增加x倍 
                (N+1)*N/2=X*N
                == N=2X-1; // 当 转移操作开销 为 X倍时 N应该等于 2X-1 
            
            -- 需要真正实现 断点续查 功能！！
                -- 输入参数 pRetNext 的定义
                    -- lastPtr ？ No，return 指针即已经是 
                    -- Nextptr ？ 有此含义
                    -- startPtr？ 最为准确
                -- search 函数 需要返回3种信息 ：
                    -- 启动位置     输入 Inx ptr
                    -- 匹配偏移标量 输出 Inx inx
                    -- 匹配指针     lastptr  lastptr
                    -- 复杂化的处理就是讲 pRetNext复用 ：传入指针，返回数值
                    
                -- 默认 pObj 不提供 可变存储空间
                 
            -- 数组表 与 链表 的勉强融合 
                没有什么特别大的益处 反而实现上有诸多限制   
                更换思路： 各类结构不同的表分类实现 子抽象
                    -- 数组表 对表项进行归纳 抽象
                    -- 链表 对 所属链表节点对象进行抽象
               
            
    7.  数组表 提供 静态特性
        链表 提供 动态特性
        表 按形式分类：
            // Item 同类
            -- 数组表
            -- 链表
            // Item 不同类
            -- T型表
                -- ID+Dlink+pItemObj ；
                -- 1值3指针 T型
            -- 指针数组表
                
        表 的按应用分类 ： 
            -- 用于存储数据
            -- 用于接收解释数据
            -- 用于任务控制
            --             
***/


/**  协作器 一些笔记
    1. 表的形态
        -- 对象数组
            -- 简单 直接; 只需要控制一个数组大小的宏即可
            -- 若需要排序则比较困难
        -- 对象链表
            -- 灵活 ，动态性好
            -- 需要动态内存分配的支持 ， 相对复杂
            
        -- 对象指针数组
            -- 相对于对象数组，更加灵活；
            -- 但是 对于表应用一般需要一个统一的基本数据结构，
                及数据项，这样才能进行有效的遍历 
            -- 与对象数组结合 配套使用；解决对象数组中的排序问题；
                -- 同时会增加一个挂接的操作
            
        -- 由于数组大小的不可修改性，所以使用数组，缺乏动态性
            So 关键是使用“表”的环境，是否需要动态性的支持；

    增删操作
        //Q 链表需要传递一个表头指针变量
        -- 根本原因：当使用链表结构时 g_Table 传递的是一个变量值复制值(目标table的地址值) (g_pASchdHeadTCB 的值），
        -- add 或del 操作 对变量值进行的修改 不会反应到变量本身中；
        -- 而链表的增删操作 需要更新表头信息 即需要修改传入的变量的值
        -- 在此例中 通过 ASchd_ModifyTableHead函数进行了修改，适配 链表结构
        -- 但因此 牺牲了一定的 可重入性            
    
*/

/*** 协作器设计思考记录
    1. 简单即优秀 
    
    2. 参考定时器方式 一个计数reg 及一个重载reg
    3. Q: OutTime 的归属 ？ 
        --从普遍性来说 应该位于此模块中；
        --从实际中考虑，只有个别程序会使用;
        -- So 本质是 pTask 中 有可能需要 在每次Updata时间中 作一些业务处理
        -- Then 后续遇到复杂业务处理可以考虑 增加回调函数 pUpdataCB ？
    4. 任务中与时间相关的行为：
        -- 周期时间 
            -- 定时执行一次
        -- 延时/挂起时间
        -- 超时时间
            -- 等待行为
        -- ？
        
    5.  pTask 自身所需要支持的基本函数
        -- Run
        -- init
        -- Reset 
        -- Del      // 释放当前所有资源
        //内部资源
        -- pPara
    
    6. 进一步： 协作调度器 是调度任务运行函数 还是 调度任务对象 好？
        -- 一个问题 任务运行函数存入对象？
            -- now 协作调度器 含有部分 任务对象 可能会使用的数据；此部分数据如何传递到 任务对象？
            -- 从任务对象的角度来看 任务所使用的所有参数都应该来自对象内部的pTask参数
                任务对象看不见 与其绑定的协作器 控制块
            -- So 协作器相当于一个容器，一个运行环境 ， 任务对象 运行在其中。
                更普遍地看，一个任务对象，应该了解其运行环境信息；
                Then 任务对象应该有一个指向运行环境的指针；
                
        --  引出此问题 源于 支持 挂起，超时 功能
            对运行的任务来说 需要使用到 运行环境的变量
            对协作器来说，任务总是RTC 意味着可以简单的在任何调用结束后 安全移除任务
            但由于 提供挂起 超时 功能 任务再也不是RTC形式了；
            
        -- 任务函数 与 任务对象 两者之间的调用处理时不一样的！
            -- 对于传入的参数对象是不同的
            -- 明显使用任务对象 更加灵活，单同时也更加复杂；
                -- 一些简单业务使用任务函数即可满足；若非要套入任务对象，会显得笨重；
                
    
    7.  对于协调度器，调度动作就是一个函数并传入参数
        -- 若要扩展为任务对象，只需要将pPara 指向任务对象实例，然后pTask 
            指向一个对任务对象进行解释并执行的函数；
        -- 对于协作调度器来说 增加了一层函数嵌套，但保持的调度器的实现的简便性；
        -- 对于任务对象，有一个指向协作器控制块的指针，用于实现相关业务的操作；
        
    8.  协作器的while(1) 超级循环
        -- 属于一个守护程序 ASchdGuard 
        -- 实现：
            -- 1）不断循环检测 执行
            -- 2）执行一次，等待协作器更新后再执行一次 ，等待事件进入休眠 or idle任务；
            -- 
            
    9.  协作任务中，一些guard属性的任务应该安放在哪里？
        -- Guard 任务检测周期比较长的 100-30ms基本的可以使用周期任务代替实现；
        -- Guard 任务检测周期比较短的？ 
            -- 单位周期任务 + 嵌入 idle任务？
            
        -- Guard 任务 ： 讲求事件处理的及时性。
            -- 问题背景： 串口发送一个数据包， 但这个数据包对应的协议定义，
            有字节间间距 的最大时间定义，so 定时的方式发送数据在波特率较高时
            会出现问题；
            
    10. ASchdGuard 的一些监控 信息：
        -- 首先从期望获得的数据 角度思考：
            -- CPU使用率 ： 忙 与 空闲 占比；
            -- 各任务 占时统计 
            -- 各任务抖动频率统计
            -- 监控一个任务的时间信息 ，对应的责任应该分配与协作器，
                因为协作器最擅长处理时间相关的信息
            
            
        -- 实现：  
            -- key 系统时间： systick 与 计数器 的计算reg的实时值获取；
                -- 接口： get_systick;get_TimeCountReg;
                -- 计算两个时间差，并转换单位；
                -- 原子操作区域；
                
            -- 时差计算：
                -- 每个任务调用前后 ，由调度器计算？
                    -- 增加了调度处理的复杂性，污染；
                    
                -- 每个任务自己计算并记录一次？然后由统计程序每次循环时提取一次？
                    -- 内存的增加： 一个事件对象：记录消息差
                    -- 对于PT 式任务，不容易在内部实现时间统计；
                
                -- 时差结构的记录？
                    diff--max--sum--avg  period/count;


                    
                
            -- 对每个调度任务进行时间差计数，然后用消息的形式 推送到统计任务的消息队列
                --机制略为复杂
                -- 此机制占用较多缓存；
                
            -- 系统任务信息的统计 必然是一次调度执行后 对一次更新信息进行收集，然后再计算处理
               
                
            -- 一个具体的要求：
                now 希望查看 任务 A B 的运行时间 统计信息；
                -- 意味着要开启对任务A or B 的时间统计行为
                    --隐含 需要对任务ID 进行过滤
                    -- 需要 
        
    
    11. 变量数据查看机制
        -- 首先需要有查看变量注册机制 
            --变量类型 及变量地址
        -- 查看变量发送更新周期，及数据包的构建；
        -- 只能查看全局变量；
        -- 为友好的节面显示，需要与上位机使用一致的结构体形式 
        
        -- 综合考虑 此机制太繁杂，价值不大，不实现；
        
    
    
    
***/

/*** 协作调度器 API 定义
    1. 分配独立ID  --ID管理
    2. 本质上是一个查表的问题，表操作
        -- 表类型 ： 链表形式 or 数组形式
        -- 基本操作： Find Operation
            -- key 查找条件 
                -- 按ID查找
                -- 按对象某相似元素查找
                -- 需要为查找函数提供一个cmp 函数 定义匹配规则
                -- 核心查找函数格式：
                TableItem_t_t (*pFind)(TableItem_t_t g_TargetTable,void* InPara,CmpRule_t pCmpFunc); 
        -- 派生的常用接口形式
        ASchdTCB_t (*pFindById)(ASchdTCB_t g_Table,int TaskId);
        ASchdTCB_t (*pFindByObj)(ASchdTCB_t g_Table,ASchdTask_t pTask);
    3. 聚焦两个问题：ID资源 与TCB资源
        -- 需要提供 获取take/归还return 操作对 以便于提供 资源管理服务
        -- take/return  与 malloc/free的概念区别：
            -- take/return 包含 malloc/free
            -- take/return 更能准确表达行为目的；
                获取可以是现成的，即刻生成的，临时的；
                与常用的malloc 中 动态分配 的概率区分开来；
        -- 对于 TCB块是否为空的判断
            -- 1. 若有id 项，可以判断id项是否为0；
            -- 2. 直接判断 pTask 函数指针是否为空指针；// 优先选择
            
        -- 对于 ID资源 管理 暂不实现，使用 指定ID接口函数 简化设计；
    
    4.  Think 协作调度器 与 PTask 的区别
        -- 场景
            -- 任务内延时 
                --协作调度器 要求任务必须为RTC形式，即若需要任务内延时，延时是阻塞的！！
                --PTask 不要求RTC形式，但需要多一个变量；延时不阻塞但延时不一定准确！！
                    --引入问题：由于是非RTC形式，因此涉及资源释放问题
                    -- PTask 需要经过N次调用才会进入一个完整结束状态，
                    -- 若在运行中退出，需要根据运行状态对内部资源进行释放
                    -- So Ptask应用场景应该是在一个一直被循环调用的环境中，
                        没有增删，只有停启复位。复位需要提供资源释放回调函数 
                    -- PTask 根据全局tick 在内部自行管理运行周期;
                        
    5.  混合式调度器
        -- 在协作式调度器基础上，在ASchd_Updata 函数结尾，执行一个RealTime_ShortRunTask 任务队列，
        -- 整个队列的运行时间 小于定时周期的一般；
        -- 队列中的所有任务 必需是RTC形式的；
        
    6.  超级while 循环中 协作任务 与 PTask任务 如何管理？
        -- 首先一旦遍历协作任务队列结束直至 下一次ASchd_Updata更新，这段时间CPU是空闲的
        -- 在这段空闲时间内 循环处理 PTask任务；
        -- 细节点：
            -- PTask任务队列的循环处理 可以以任务为单位 被打断；
                --so 意味着需要有一个当前运行任务指针保存 信息；
            -- PTask任务 若为 长时间任务， 应该进行适当切分 使其运行表现为短时任务
            -- PTask长时任务 会引起系统抖动 ， 需要引入监测机制 ，在调试阶段优化
            -- PTask任务循环运行时间应该 自动适应 剩余时间片 进行预判 减少 引起的系统抖动
                -- 意味着需要 知道每个任务的运行时间 均值，最大值，知道每次大循环的时间使用情况
                -- 意味着需要一个us级别的定时器专门用于时间的统计; or 获取时标定时器的当前计数值
                -- 设置一个时间阀值T，若剩余时间小于T ,暂停Ptask循环; 进入空闲状态；

            -- So 整个系统有3个优先级任务 定时中断队列--周期协作队列-- PTask队列;
            -- 
    7.  增删改查 存储加载
        改： int Set(pItem,ParaId,val32);
    
    8.  常用结构 对象
            -- 表 ，数据对象，队列 
    
    9. Q 如何统一 数组表 与链表 的增删操作接口参数
        -- 一级指针 ： 传递表头地址，
            so 表头地址修改是无效的
        -- 二级指针 ： 传递表头指针的地址
            so 表头地址修改是有效的
            
        -- 矛盾，对数组表来说直接使用一级指针是方便的，而且，getobj 操作，通常也是返回一级指针；
            -- 若要修改为二级指针形式，
            -- getobj需要设置为返回指针地址
            
            -- 缺乏一个统一 表头描述结构！！
            -- 单引入表头描述结构-- 会增加接口的复杂度？
            -- 换位思考：这里的表是一个抽象的概念
                自然 为这个抽象 定义一个结构体也是合适的
        
        -- 另一种方法：
            -- 引入一个ModifyTableHead()函数;
            -- 映射当前表头与值与表头指针之间的关系;
            -- 暂时使用该方法 2018-02-01
    
***/

/***  双链表操作  笔记
     
    1. 注意几个基本node操作
    2. 注意几个基本宏操作 CC_OFF_SET_OF CC_LIST_ENTRY
    3. note： 若经常需要查链，可以通过将链表转换为指针数组 再进行操作。
        而每次增删改链表 都通过调用一个updata函数更新对应的指针数组即可;
        --think 是否有真实优化？
    //
    4. 双链表代码 应该关注的本子关键点如下：
        -- 双链表结构，及跳回包含链表节点成员的 宏的实现原理
        -- 链表节点间的操作 ：插入与移除; CC_DLink_AddAfter
        -- 链表操作中的 Find
            -- 查找接口的基本形式
            -- 链表遍历的代码结构
            -- Find==遍历结构+Cmp函数
            -- Cmp函数的参数规定：第一个参数为比较输入参数，第二个参数为链表节点！！
            -- Find 提供两个基本函数，一个返回匹配对象指针，一个返回匹配对象偏址;
        -- 表的查找 行为 汇总 ？
            -- 参数--对象指针
            -- 参数--对象位置
            -- 位置参数--对象指针
                --由于 cmp函数是传入节点对象，无位置信息，所以必须独立实现
                
            -- 对象指针参数--对象位置 
            -- 对象指针参数--是否存在？ 
            
    5. Q 接口参数 指针 pLinkHead 是否将会修改？
        -- 对于查找 Find 行为，不会修改， 所以只需要传递指针即可
        -- 对于增删等，将修改链表结构的行为 表头指针的值是会修改的。
            -- So 对于“表” 的描述，独立的表头指针变量 是不可或缺的；
            -- HeadPtr+Table
            -- 所以对于基本增删函数接口，确定传递的是表头指针地址 ！！
            
    6. 角度 ：
        node与node 之间的操作
            -- node 初始化
            -- node insert --目标node 前or后
            -- node 移除  
            -- 新node 替换 目标node
        链表与node 的操作
            -- Find 
                -- 返回对象      Find       //cmp 输入参数与node对象
                -- 返回对象偏址  GetIndex   //cmp 输入参数与node对象
                -- 通过偏址查找，返回对象指针
                -- 通过对象指针，返回对象偏址 -- 用于判断是对象否存在于链表
            -- add、Insert
                -- Insert 操作 是基本操作
                    -- 空链表处理 + （inx == 0 or -1）
                        -- 设置表头指针
                    -- 非空链表处理
                        -- 插入尾部
                        -- 插入中间or首部
                            -- 插入首部则更新 表头指针；
                -- AddHead AddTail
                    -- 可以使用Insert 实现；or 另外自行实现
                    -- 自行实现 效率，嵌套层次上的考虑
            
            -- Del 
                -- DelByNodePtr
                    -- 通过节点指针移除节点，返回移除节点的指针;
                    -- 对于删除操作
                        -- 首节点
                            -- 唯一首节点
                            -- or 非唯一首节点
                            --更新表头指针
                            
                        -- 非首节点
                            -- Find node
                            
                -- DelByNodeInx
                    -- 。。。。
        
        链表管理结构 与 节点
            基于基本操作封装
            -- 提供增删
            
        
    7. 
            
*******************************************/

/*** Basic FIFO 设计笔记 
1. 核心体现：
    --Loop_Count 环形缓存的占用空间计算方法；
    --数组标offset 的环形计算 -- (实现方式：三元操作 or +1取余操作)
    --实际空间=可用空间+1；避免产生歧义
    --每提取一个字节数据后 将缓存清0
2.  基本读写接口的设计
    uint32 FIFO_Read(CC_FIFO_t p2fifo ,uint32 rlen, uint8*rbuf,uint32 rbufSz)
    uint32 FIFO_Write(CC_FIFO_t p2fifo,uint32 wlen, uint8*wbuf,uint32 wbufSz)
3. 

***********************************************/

/*** 队列的几种实现方法

    LenPkg格式的队列 在应用上 比ByteFIFO 更好
    ByteStream to pkg 使用 “识别器” 方法 实现
    
    方法1
    QueType_VariableLength + ElementSize ==0
    1. 以队列元素为单位 即CC_BUF --描述一块内存空间
    2. 通过动态分配 / 释放 以实现实际pkg 的存取
    3. QueueSize 表示队列的最大元素个数
       ElementSize 无意义or 表示最大pkg长度限制

    方法2
    QueType_VariableLength2 
    1. 变长实现方法2
        --ElementSize 表示pkg|元素 最大长度
        --QueueSize 表示最小要容纳的元素个数
    2. 格式 len32+pkg;
    3. len32 自动插入清除
    4. pkg 完整提取

    Q: 对于 QueType_VariableLength2 如何快速提取len32字段是一个需要考虑的因素
    不能影响数据复制的速度！！
    A: 通过接口形式可以知道,数据必需以数据包形式输入，
    只有在真正进行复制前 先计算好各条件即可。
    所以不会有太大影响。    
 
    Q ElementSize QueSize 两个参数是否有必要作区分
    A 暂时不需要明确区分， 
        一般队列缓存不需要限制数据包大小
        -- 除非遇到 内存十分充足的的情况
        -- 而且当真正有需求时完全可以在外层实现限制

    与fifo相似，
    1.note queue实现不依赖fifo模块
    2.  QueType_VariableLength 方法1.  
            单队列的每个元素使用 CC_BUF 结构，通过动态分配空间，实现pkg的排队
        QueType_VariableLength2 方法2， 
            每个改变保存格式 len32+pkg，入队 自动添加len32字段 
    3.init操作依赖 ASStoreOP CC_BUF 对象操作  

        
*/


/***  基于双链表 元素的结构组织demo
    //观察者模式 、 发布订阅
    1. DLink+自定义对象
    2. 遍历链表+处理
    3. 基础操作

    4. int (*pCBFunc)(SubscibeNode_t p2self,uint32 len,uint8* pPkg);
        --一种 用于处理 数据包 通用接口结构；
        -- p2self 传入一个对象，对象直接or间接包含处理数据包的所有信息
    
    5. subject 与 Observer 是成对绑定的    
    
    6. 以发布订阅的形式 实现1对N 的分发行为 结构；
    
    7. 将1对1结构扩展成1对N结构 --观察者模式
    8. 观察者模式 -- 有解耦合作用
        -- 是一种数据监听 模式
        -- 数据流复制，广播机制
        -- 订阅点 即数据接收点
    9. 观察者是事件驱动型
        -- 观察者对应的行为实现： RTC型
        -- 
        
*/

/*** 标准 观察者模式 笔记
    1. 对于具体对象 ，需要提供一个对象比较函数
    2. CC_LIST_ENTRY(A,struct _ObserverNode, LNode)
    3. 设计要点：
        1. 信息传递 接口使用 抽象的“obj+len+pkg” 格式
        2. 观察者 有一个参数扩展 指针用于 接收msg后的处理；
        3. Notify函数的标准实现 
            -- 链表的遍历 调用
            -- 利用了链表的灵活性
        4. 由于涉及到 节点 增删操作
            -- 需要链表查找
            -- 进而必需提供 一个比较函数 
            -- 简单的解决方法：
                节点对象 包含一个ID属性
            
        5. 主题对象 主要是包含链表信息及管理
            
***/

//===========
/* Design Note
    1. 数据表设计 
        -- 占空内存空间，尽量精简
        -- 表项设计
            1. 是否需要控制各项数据的更新周期
                -- 如同协议的周期查询命令的发送 设置
            2. Val[]域
                -- 占用32位 ，使用一个共用体 表示
                -- 可以比较方便地切换几种基础数据类型
                -- 是否需要 ValTpye 字段 指明数据类型？
            3. 是否需要区分 
                固定参数域 Fixed      
                可变参数域 Variable
                
            ID[]+Val[]+ValTpye[]
                +pUpdata[]+PeriodMs[]+LastTick[] //
                +Ctrl[OnOff]
                +Factor[]   //系数 将Val放大N倍输出   
                +pFixed[]
                +pVariable[]
                
        -- 抽象表项 思考
            -- 值    [ 时间因素 状态相关 范围 类型   ]
            -- 行为  [更新 提取/处理 转换]
            
            ID[]
                +pFixed[]       // 通用固定的属性            
                    -DataType[ n种 ]    // 最高位表示: pData域 ：指向一个[对象] or 以本身空间存储一个数据[指针or值] 
                    -DataRange[Max,Min]
                    -Ctrl[OnOff]        //
                     
                +pVariable[]    //  通用的易变属性 
                    -pData[]            // 指向实际数据内容 ，void*, [值，值指针，数组指针，指向一个对象， ]
                        -Status[DataChange-Vaild-OutRange-]    // 通过标准RW函数 和 定时遍历 ；来维护 --StatusUpdata();  
                        -LastUpdataTick[]
                        -TimeOutMs[]       // Vaild == if[LastUpdataTick,TimeOutMs]
                    
                    -BehaviorFuncArray[]   // 行为函数指针; 更新数据-处理[数据/命令]
                        -LastCallTick[]     // 与 LastUpdataTick[] 含义相似
                        -UpdataPeriodMs[]
                        -pUpdataFunc[]          //获取原始数据->服务于 pData域 ; 周期式
                        
                        -pProcessFunc[]         //传入原始数据-->按ID处理数据 ; 触发式

                    
                +pExFixed[]   // 扩展的固定属性
                +pExVariable[]// 扩展的易变属性
                
                
    2.  任务
        -- 周期更新任务
            -- 每项数据有 不同的更新周期
            -- 任务调用周期尽可能快
                1ms
            -- Updata函数在数据 需要主动去获取时 才需要实现！！

            
            
        -- OutVal 周期更新函数
            -- 控制的足够细的话需要 分配一组时间变量来 配置更新
            -- 粗略控制的话只需要一个统一的时间就可以
                此统一时间就是 该任务的调度时间
            -- 使用任务时间 周期   
                
                
        -- OutVal 周期输出、广播函数
            -- 所有数据打包输出
            -- 使用任务时间 周期
        
        -- OutVal 变化即时输出 
            -- 任务尽可能快地检测
        
        
        -- So 都需要一个遍历函数
            -- 对于数组 一个for循环即可
            -- 差异 对Item 的不同域的处理
    
    3.
         
        
        
    
    
*/

/* Note OBDCalcItem 数据结构设计
    1. 表项结构设计：
        -- 来源数据 ： Cmd[] + Data[] 两个域
        -- 关注Data 数据段内容
        -- 一个 Cmd 可能对应多个 数据ID值（OBDDataID）
            -- 1对N的问题
                --交由调用PGNx_Updata函数处理的
                -- Or 在表项中建立 关系
            -- 映射关系 OBDDataID 对应 Cmd+Data[s,e] 
        
    2. 大小端 的Data 数据提取
        -- 以大端存储视图为标准 ：
            0x01234567 == [0x01,0x23,0x45,0x67];
            在大端模式下，使用bit尺度截取Data数据域是比较适合的
            
        -- 从小端角度出发 使用bit尺度截取Data数据域是不合适的；
            -- 原因：小端 是按字节顺序 定义反序 而字节内的bit定义时不变的; 
            -- So 从程序数据使用上看 使用大端顺序是比较好的；
            
        
*/

#if 0 //协议demo Note
/* Design Note : 
    
    1. 从 StdCanMsg 格式 到 J1939协议格式
        -- J1939 格式 ：
            -- 扩展帧--CanId 有29bit 
            -- P[3]+R1[1]+DP[1]+PF[8]+PS[8]+SA[8]   //bit
            So: 实际CanID存储格式：
                H[3]+P[3]+R1[1]+DP[1]+PF[8]+PS[8]+SA[8]
                H[3] 是填充位,填充0；
                
            -- 注：从reg存储格式到 STM32标准库 输出的CAN数据格式已经将CANID 与其他位分离存储,
                    并且，CANID已经实行向右端，低位对齐；
        -- 对于J1939应用 
            --  从接收端看 CANID应该划分成：
                CanId == H[3]+P[3]+PGN[18]+SA[8]
                转化成 ：PGNID == H[6]+PGN[18];
                So：应该需要一个 提取函数 ExtractPGNFromExcanID 
            
            -- 从发送端看 输入也是与PGN相关
    
    2.  解释器 接口函数
        --  对外接口 int (*pInterpretation)(uint32 Len,uint8* pPkg);
            内部接口 int (*pInterpretation)(StdCanMsg_t pPkg);
            对外需要保持统一性，通用性；
        
        --  自定义一个表项结构
        
        
            
*/

/* Note1 请求数据包发送函数
    
    -- 此处应该有一个请求命令表
        -- reqcmd+periodms
    
    -- g_J1939_RequTable
        // 通过 PUB_NULL 屏幕 cmd域的重复
        // OBDREQU_BROADCAST == OBDREQU_OFF ; 使用OBDREQU_BROADCAST 表明此数据是 主观关闭 还是不需要主动查询
    
    -- 两个函数一个表 -->  实现周期请求命令的发送  
        
*/

/* Note2 协议解释器  
    0. 接口形式 int XXX_Interpretation(uint32 Len,uint8* pPkg)
    
    1. 输入: StdCanMsg 结构的数据包;
        -- 关注PGN值 ，PGN代替ID
        --  OBDDataID 对应 pgn 及其 Data域的某部分
        -- So OBDDataID 对应 pgn+Data[s,e]         
    
*/

/* Note3 Ptcl Filter
    -- 协议对应的过滤器
*/

/* Note4 Ptcl_J1939 OBSV 节点
    -- 此处主要是接口格式的变换
    -- g_ObsvPtcl_XXX 对象 + int ObsvPtclNode_XXX(ObserverNode_t p2self,uint32 PkgLen,uint8* pPkg)
    
*/

/* Note5 协议初始化函数
    1. 协议的初始化
    2. 重新 AppCanPkg的 过滤函数
    3. 通过 OBSV 对象 将协议的数据流输入接口 挂接到 CanPkg 广播总线上
    4. So 一个协议模块 对外 输入端接口 函数如下：
        -- Init
        -- Filter
        -- Interpretation
            -- 真正执行数据包的解释
            
        输出端口
        -- 需要 指示 一个存储计算结果的位置
        
    // 从协议模块角度看

    模块的生存过程有：
        1. 系统能知道有哪些协议模块
            --  统一放置在指定的数组中
            --  系统初始化时，需要调用模块初始化
            --  模块初始化的目的是 注册模块 
                让系统知道有这个模块 ，不做其他多余的事情
        2. 当需要使用模块时：
            -- 明显 需要挂接模块 和移除模块 两种操作
            
    
*/

#endif

/*** NotStdPtcl Mode Design Note : 
    
    1. 非标数据
    2. 对CAN数据包直接进行解释
    3. 请求命令部分 
        -- 可选开通 
            -- 先阶段不需要使用
    4. 对于CAN 命令 的demo来说
        -- 关心 CANID + DATA[8] 两个字段域
        -- 
        
    5. Interpretation 与 Filter 区别
        -- Interpretation ： ID匹配后 调用执行函数
        -- Filter ： 仅ID查找匹配
    
    6. 仅从接收角度来看，
        1. 关键点 原始输入数据 与 一个表 之间的 匹配
        2. Interpretation 与 Filter
            -- 是协议代码结构的关键函数
            -- Search 函数是一个 查找的结构关键函数

        3. 问题域：数据输入流的解释处理
            关键在于 比较函数 与 表结构的设计            
            由于应用了通用、抽象表对象 结构，
                -- 1. 表结构可以任意定义 与 search 函数无关
                -- 2. 根据上一点，要求 一个特定的表结构应该有器对应的 特定比较函数
            由此问题域转换为 CMP函数
                -- CMP函数 输入 item 与 数据包
                    -- 一般来说数据包是帧格式，Item是自定义格式
                    -- 帧格式中的 关键数据常常不能 直接提取 需要处理
                    -- 所有会产生一个效率问题：一个帧数据包需要被重复解释 TableSize次 ！！
                
                -- 所以关键关系 应该有 table结构，比较函数 ,帧关键数据提取函数
                    -- 但 明显 一般编码顺序是先执行 帧关键数据提取函数  表遍历 循环调用比较函数 
                        -- 这样，由于 帧关键数据提取函数 返回的数据形式是不确定的所以
                            会破坏 Interpretation 与 Filter 的结构
                        
                    -- 技巧：一次 search 遍历中 传入 的pPkg指针 是一致的
                        所以可以 将 帧关键数据提取函数 放在CMP 函数中执行
                        采样内部 static 变量 检测 pPkg 参数 
                        若改变 更新 调用 帧关键数据提取函数 更新值;
                        
                    关键问题：传入的pPkg指针 在特殊场合下不变但数据内容是会变化的
                    -- 完全解决方法，修改 CMP函数接口，提供一个额外的标志 用于CMP 判断
                    是否是在一次 search 遍历内;
                        

            对于 Interpretation
                -- 明显对表结构作出了一些必要的元素要求
                    -- 即匹配成功后的 处理函数[ 接口形式，成员名称 ]
            
                
                    
                
               
            
*/


/***  Note OBDSys

    1.  管理整个OBD 库，系统的运行
    2. 管理内容
        --ObdSys Status 系统状态、模式：
            --以及参数传入 基本功能初始化 -- 注册 -- 初始化 -- 协议识别and初始化 -- 进入正常工作模式 
        
        -- 注册
            -- Flash Write操作
            -- GuardTask
            -- 检测是否已经注册
            -- 若未注册 
                -- 被动 ： 等待注册
                    -- 通过注册接口 ，注册命令设置
                    
                //-- 主动 : 某些条件下，周期尝试进行注册
            
            -- 
        
        -- 参数
            -- 车型参数 uint32 
            -- 车型宏定义表
            -- 参数配置
            -- 简化，不保存参数；启动时传入！！
        
        -- 非标的左右转向灯 信息的处理
            --  独立出来的非标数据处理 
            --  依赖于标准协议，在CAN包的 广播总线上添加一个非标命令的解释 模块，
            
        --      

    3. Obd 模块初始化
        -- 分为3个阶段初始化
            -- 基础模块初始化
            -- 应用基础模块初始化
            -- 应用初始化    
                --协议搜索识别及绑定
        
*/









